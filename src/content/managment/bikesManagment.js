import {
  addDoc,
  collection,
  deleteDoc,
  doc,
  getDocs,
  query,
  setDoc,
  where,
} from "firebase/firestore";
import {
  deleteObject,
  getDownloadURL,
  ref,
  uploadBytes,
} from "firebase/storage";

import { db, storage } from "../firebase/firebaseConfig";
export const addBike = async (available, modal, color, location, bikeImage) => {
  try {
    let data = {
      modal: modal,
      color: color,
      location: location,
      available: available,
      rating: "1",
    };
    const res = await addDoc(collection(db, "bikes"), data);
    // uploading bike image to firebaseStorage
    // rename image to bike id
    // id is autoGenerated by fireStore with addDoc
    if (bikeImage && bikeImage.name.match(/\.(jpg|jpeg|png|gif)$/i)) {
      const bikeObject = await UploadBikeImage(
        res._key.path.segments[1],
        bikeImage,
        res,
        data
      );
      return bikeObject;
    } else {
      await setDoc(
        res,
        { imageUrl: null, bikeid: res._key.path.segments[1] },
        { merge: true }
      );
      return { ...data, imageUrl: null, bikeid: res._key.path.segments[1] };
    }
  } catch (error) {
    alert("error please retry");
    return null;
  }
};

export const UploadBikeImage = async (bikeid, bikeImage, bikeRef, data) => {
  try {
    const imageRef = ref(storage, `bikeImgs/${bikeid}`);
    await uploadBytes(imageRef, bikeImage);
    //get image url and update document and add imageUrl to it
    const url = await getDownloadURL(imageRef);
    await setDoc(
      bikeRef,
      {
        imageUrl: url,
        bikeid: bikeid,
      },
      { merge: true }
    );
    return { ...data, imageUrl: url, bikeid: bikeid };
  } catch (error) {
    alert("upload error");
    return null;
  }
};

export const editBike = async (bikedata, bikeImage) => {
  try {
    await setDoc(
      doc(db, "bikes", bikedata.bikeid),
      {
        modal: bikedata.modal,
        color: bikedata.color,
        location: bikedata.location,
        available: bikedata.available,
      },
      { merge: true }
    );
    if (bikeImage && bikeImage.name.match(/\.(jpg|jpeg|png|gif)$/i)) {
      const bikeObject = UploadBikeImage(
        bikedata.bikeid,
        bikeImage,
        doc(db, "bikes", bikedata.bikeid),
        bikedata
      );
      return bikeObject;
    } else return bikedata;
  } catch (error) {
    alert("error please retry");
    return null;
  }
};

export const getBikes = async () => {
  try {
    const docRef = collection(db, "bikes/");
    const bikes = await getDocs(docRef);
    let bikesArray = [];
    bikes.forEach((doc) => {
      bikesArray = [...bikesArray, { id: doc.id, ...doc.data() }];
    });

    return bikesArray;
  } catch (error) {
    alert("Server error");
    return null;
  }
};

export const deleteBike = async (bikeid) => {
  try {
    const bikeRef = doc(db, "bikes/", bikeid);
    await deleteDoc(bikeRef);
    //delete image from storage
    const desertRef = ref(storage, `bikeImgs/${bikeid}`);
    await deleteObject(desertRef);
    // delete all reservation with bikeid
    const reservQ = query(
      collection(db, "reservations/"),
      where("bikeid", "==", bikeid)
    );
    const reservations = await getDocs(reservQ);
    // delete every single reservation
    reservations.docs.map(async (e) => {
      await deleteDoc(e.ref);
    });
    return bikeid;
  } catch (error) {
    console.log(error);
    return null;
  }
};

export const reserveBike = async (userId, bikeid, startDate, endDate) => {
  try {
    const ref = await addDoc(collection(db, "reservations"), {
      userId,
      bikeid,
      startDate,
      endDate,
    });
    await setDoc(ref, { rid: ref._key.path.segments[1] }, { merge: true });
    return true;
  } catch (error) {
    console.error();
    return false;
  }
};

export const cancleReserv = async (rid) => {
  try {
    await deleteDoc(doc(db, "reservations", rid));
    return rid;
  } catch (error) {
    alert("error please retry");
    return false;
  }
};

export const getBikesByIds = async (idsArray) => {
  try {
    const bikesQ = query(
      collection(db, "bikes/"),
      where("bikeid", "in", idsArray)
    );
    const bikes = await getDocs(bikesQ);
    let bikesArray = [];
    //push reserved bikes to bikesarray
    idsArray.forEach((bikeid) => {
      bikes.forEach((doc) => {
        if (doc.data().bikeid === bikeid) bikesArray.push(doc.data());
      });
    });

    return bikesArray;
  } catch (error) {
    console.error("Server error");
    return null;
  }
};

export const getUserReservedBikes = async (uid) => {
  try {
    const reservQ = query(
      collection(db, "reservations/"),
      where("userId", "==", uid)
    );
    const reserv = await getDocs(reservQ);
    // get reservedbikes ids along with there time period
    const data = await spreadBikesData(reserv);
    if (data && data.reservArray?.length > 0) {
      let reservArray = data.reservArray;
      let timeArray = data.timeArray;
      //get bikes by id
      const reservedBikes = await getBikesByIds(reservArray);
      //include the time period to bikes objects
      const mergedValues = reservedBikes.map((bike) => {
        let timeperiod = timeArray.find((e) => e.bikeid === bike.bikeid);
        timeArray.splice(timeArray.indexOf(timeperiod), 1);
        return { ...bike, ...timeperiod };
      });
      return mergedValues;
    } else return null;
  } catch (error) {
    console.log(error);
    alert("Server error");
    return null;
  }
};

const spreadBikesData = async (docsData) => {
  try {
    let reservArray = [];
    let timeArray = [];
    docsData.forEach((doc) => {
      reservArray = [...reservArray, doc.data().bikeid];
      timeArray = [
        ...timeArray,
        {
          bikeid: doc.data().bikeid,
          startDate: doc.data().startDate,
          endDate: doc.data().endDate,
          rid: doc.data().rid,
        },
      ];
    });
    return { reservArray, timeArray };
  } catch (error) {
    console.error("spread Error");
    return null;
  }
};

export const getAvailableBikesbyTime = async (startDate, endDate) => {
  try {
    const docRef = collection(db, "reservations");
    const reservations = await getDocs(docRef);
    let reservationsArray = [];
    reservations.forEach((doc) => {
      reservationsArray = [...reservationsArray, { id: doc.id, ...doc.data() }];
    });
    // filter reservations with time period
    let ReservedBikes = [];
    for (const reserv of reservationsArray) {
      if (
        (startDate >= reserv.startDate && startDate <= reserv.endDate) ||
        (endDate >= reserv.startDate && endDate <= reserv.endDate) ||
        (endDate >= reserv.endDate && startDate <= reserv.startDate)
      ) {
        ReservedBikes = [...ReservedBikes, reserv.bikeid];
      }
    }
    if (ReservedBikes.length > 0) {
      const availablebikes = await getAvailableBikes(ReservedBikes); // remove reserved bikes from bikes list
      return availablebikes;
    } else {
      const allbikes = await getBikes(); // get all bikes if there is no reserved bike in that period
      return allbikes;
    }
  } catch (error) {
    alert("Server error");
    return null;
  }
};

export const getAvailableBikes = async (reservedBikes) => {
  try {
    const docRef = collection(db, "bikes/");
    const q = query(docRef, where("bikeid", "not-in", reservedBikes));
    const bikes = await getDocs(q);
    let bikesArray = [];
    bikes.forEach((doc) => {
      bikesArray = [...bikesArray, { id: doc.id, ...doc.data() }];
    });

    return bikesArray;
  } catch (error) {
    alert("Server error");
    return null;
  }
};
